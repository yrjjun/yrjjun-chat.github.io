<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ··åˆåŠ å¯†èŠå¤©å®¤</title>
    <style>
        /* ä¿æŒåŸæœ‰æ ·å¼ä¸å˜ï¼Œæ–°å¢ä»¥ä¸‹æ ·å¼ */
        .encryption-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            background: #28a745;
            color: white;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .encryption-status::before {
            content: "ğŸ”’";
            font-size: 1.2em;
        }
        .encryption-status.inactive {
            background: #dc3545;
        }
        .encryption-status.inactive::before {
            content: "âš ï¸";
        }
    </style>
</head>
<body>
    <!-- ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ -->
    
    <div class="encryption-status" id="encryptionStatus">æ­£åœ¨å»ºç«‹å®‰å…¨è¿æ¥...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.2/jsencrypt.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script>
        // æ–°å¢å¸¸é‡
        const MessageType = {
            JOIN: 'join',
            MESSAGE: 'message',
            KEY_EXCHANGE: 'key_exchange',
            SYSTEM: 'system'
        };

        // ä¿®æ”¹åçš„å˜é‡
        let aesKey = null;
        let keyExchangeTimeout = null;
        const KEY_EXCHANGE_TIMEOUT = 5000;

        // ä¿®æ”¹generateKeyPairå‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰

        // æ–°å¢AESå¯†é’¥ç”Ÿæˆå‡½æ•°
        function generateAESKey() {
            return CryptoJS.lib.WordArray.random(32).toString();
        }

        // ä¿®æ”¹joinChatå‡½æ•°
        function joinChat() {
            // ...åŸæœ‰ä»£ç ...

            client.on('connect', () => {
                // ...åŸæœ‰ä»£ç ...
                
                // ç”Ÿæˆå¹¶å‘é€AESå¯†é’¥
                aesKey = generateAESKey();
                sendKeyExchange(aesKey);
                startKeyExchangeTimer();
            });

            // ...åŸæœ‰ä»£ç ...
        }

        // æ–°å¢å¯†é’¥äº¤æ¢å‡½æ•°
        function sendKeyExchange(key) {
            const encryptor = new JSEncrypt();
            encryptor.setPublicKey(targetPublicKey);
            const encryptedKey = encryptor.encrypt(key);

            const message = {
                type: MessageType.KEY_EXCHANGE,
                key: encryptedKey,
                timestamp: new Date().toISOString()
            };
            sendEncryptedMessage(message);
        }

        // æ–°å¢è¶…æ—¶å¤„ç†
        function startKeyExchangeTimer() {
            keyExchangeTimeout = setTimeout(() => {
                if (!aesKey) {
                    showError('å¯†é’¥äº¤æ¢è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•...');
                    sendKeyExchange(generateAESKey());
                    startKeyExchangeTimer();
                }
            }, KEY_EXCHANGE_TIMEOUT);
        }

        // ä¿®æ”¹æ¶ˆæ¯å¤„ç†é€»è¾‘
        client.on('message', (topic, payload) => {
            if (topic !== myTopic) return;

            try {
                const decrypted = decrypt.decrypt(payload.toString());
                if (!decrypted) return;

                const msg = JSON.parse(decrypted);
                switch (msg.type) {
                    case MessageType.KEY_EXCHANGE:
                        handleKeyExchange(msg);
                        break;
                    case MessageType.MESSAGE:
                        handleMessage(msg);
                        break;
                    case MessageType.JOIN:
                        handleSystemMessage(msg);
                        break;
                }
            } catch (e) {
                console.warn('æ¶ˆæ¯å¤„ç†å¤±è´¥:', e);
            }
        });

        // æ–°å¢å¯†é’¥å¤„ç†å‡½æ•°
        function handleKeyExchange(msg) {
            try {
                const receivedKey = decrypt.decrypt(msg.key);
                if (receivedKey) {
                    aesKey = receivedKey;
                    updateEncryptionStatus(true);
                    clearTimeout(keyExchangeTimeout);
                    showSystemMessage('å®‰å…¨è¿æ¥å·²å»ºç«‹');
                }
            } catch (e) {
                console.error('å¯†é’¥è§£å¯†å¤±è´¥:', e);
            }
        }

        // ä¿®æ”¹æ¶ˆæ¯å¤„ç†å‡½æ•°
        function handleMessage(msg) {
            try {
                if (aesKey) {
                    const bytes = CryptoJS.AES.decrypt(msg.content, aesKey);
                    msg.content = bytes.toString(CryptoJS.enc.Utf8);
                    if (!msg.content) throw new Error('è§£å¯†å¤±è´¥');
                }
                displayMessage(msg, msg.nickname === nickname);
            } catch (e) {
                showError('æ¶ˆæ¯è§£å¯†å¤±è´¥');
            }
        }

        // ä¿®æ”¹å‘é€æ¶ˆæ¯å‡½æ•°
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const content = input.value.trim();
            if (!content) return;

            const message = {
                type: MessageType.MESSAGE,
                nickname: nickname,
                content: aesKey ? CryptoJS.AES.encrypt(content, aesKey).toString() : content,
                timestamp: new Date().toISOString()
            };

            // å¦‚æœå°šæœªå®Œæˆå¯†é’¥äº¤æ¢ï¼Œä½¿ç”¨RSAåŠ å¯†
            if (!aesKey) {
                const encryptor = new JSEncrypt();
                encryptor.setPublicKey(targetPublicKey);
                message.content = encryptor.encrypt(content);
            }

            sendEncryptedMessage(message);
            displayMessage({ ...message, content }, true);
            input.value = '';
        }

        // æ–°å¢åŠ å¯†çŠ¶æ€æ˜¾ç¤º
        function updateEncryptionStatus(active) {
            const status = document.getElementById('encryptionStatus');
            status.classList.toggle('inactive', !active);
            status.textContent = active ? 'ç«¯åˆ°ç«¯åŠ å¯†å·²å¯ç”¨' : 'åŠ å¯†è¿æ¥ä¸å¯ç”¨';
        }

        // ä¿®æ”¹ç³»ç»Ÿæ¶ˆæ¯å¤„ç†
        function handleSystemMessage(msg) {
            displayMessage({
                ...msg,
                content: `${msg.nickname} åŠ å…¥äº†èŠå¤©`,
                type: MessageType.SYSTEM
            }, false);
        }

        // åˆå§‹åŒ–åŠ å¯†çŠ¶æ€
        updateEncryptionStatus(false);
    </script>
</body>
</html>
